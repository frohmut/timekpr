#!/bin/bash

# timekpr.sh - simple 
# watches gnome sessions and logs them out once the user has exceeded a set, per day limit
# /var/lib/timekpr/$username.time hold a count of seconds user has had a gnome session
# /var/lib/timekpr/$username hold the daily allowed seconds for the user and other configurations
#

# Ubuntu - you are required to execute command, in order for the program to work properly:
# apt-get install libnotify-bin

# Copyright / License:
# Copyright (c) 2008 Chris Jackson <chris@91courtstreet.net>
# Further developed by Even Nedberg <code@nedberg.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# See <http://www.gnu.org/licenses/>. 
#

## CONFIGURE START - You can change the following values:

# The default limit is used to set a time limit.
# New users are given by default a limit of 86400 seconds.
# The limit is expressed in seconds, e.g. 86400 means all day
default_limit=86400

# This is the grace period, where a notification pops up letting the users
# know that their time usage will be over soon.
# Users are given by default 120 seconds to finish up their work.
# Limit is expressed in seconds, e.g. 120 means 2 minutes
grace_period=120

# How often should the script check the timelogs.
# Setting is expressed in seconds, e.g. 45 means 45 seconds.
poll_time=45

# When are the users allowed to login, uncomment to enable
# (remove the '#' character in the following line).
#from=7

# Users will no longer be allowed to login after this time/hour
# (24-hour format), e.g. 22 means after 10 o'clock pm.
#to=22

## CONFIGURE END - Do not edit after this line!

#Create a log?
DEBUGME="yes"
LOGF='/var/log/timekpr.log'
[[ -e $LOGF ]] && rm -f $LOGF
touch $LOGF
#To log: [[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` Something" >> $LOGF

#Default directory
TIMEKPRDIR=/var/lib/timekpr

#Check if it exists, if not, create it
[ -d $TIMEKPRDIR ] || mkdir $TIMEKPRDIR

#Ubuntu uses alternatives so we look for x-session-manager instead of gnome-session
SESSION_MANAGER=x-session-manager

[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` Started timekpr" >> $LOGF

function notify() {
	# get the display and xauthority used by out session manager
	UDISPLAY=`grep -z DISPLAY /proc/$pid/environ | sed -e 's/DISPLAY=//'`
	XAUTHORITY=`grep -z XAUTHORITY /proc/$pid/environ | sed -e 's/XAUTHORITY=//'`

	# find DBUS session bus for this session
	DBUS_SESSION_BUS_ADDRESS=`grep -z DBUS_SESSION_BUS_ADDRESS /proc/$pid/environ | sed -e 's/DBUS_SESSION_BUS_ADDRESS=//'`

	# use it - give a warning, then another one half way through grace_period
	[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` notify: Sending first notification.." >> $LOGF
	XAUTHORITY="$XAUTHORITY" DISPLAY="$UDISPLAY" DBUS_SESSION_BUS_ADDRESS="$DBUS_SESSION_BUS_ADDRESS" \
notify-send --icon=gtk-dialog-warning --urgency=critical -t 10000 "$1" "Your session is about to expire, you have $(($grace_period/60)) minutes to save your work and log out."
	sleep $(($grace_period/2))   # FIXME: this gives other sessions a free grace_period added to their accounting
	echo -ne "\007"

	[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` notify: Sending second notification.." >> $LOGF
	XAUTHORITY="$XAUTHORITY" DISPLAY="$UDISPLAY" DBUS_SESSION_BUS_ADDRESS="$DBUS_SESSION_BUS_ADDRESS" \
notify-send --icon=gtk-dialog-warning --urgency=critical -t 10000 "$1" "Your session is about to expire, you have $(($grace_period/120)) minutes to save your work and log out."
	sleep $(($grace_period/2))   # FIXME: this gives other sessions a free grace_period added to their accounting
	echo -ne "\007"

	[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` notify: Sending third and shutdown notification.." >> $LOGF
	XAUTHORITY="$XAUTHORITY" DISPLAY="$UDISPLAY" DBUS_SESSION_BUS_ADDRESS="$DBUS_SESSION_BUS_ADDRESS" \
notify-send --icon=gtk-dialog-warning --urgency=critical -t 10000 "Shutting Down" "Shutting down session ($pid) now.." 
}

function logOut() {
	# FIXME: should really check to see if user has logged out yet 
	[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` logOut: Killing..." >> $LOGF
	#this is a pretty bad way of killing a gnome-session, but we warned 'em
	kill -9 $pid > /dev/null
	echo "Result: $?" >> $LOGF
	[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` logOut: Sent kill command" >> $LOGF
	touch $TIMEKPRDIR/$username.logout
	[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` logOut: touched $username.logout" >> $LOGF

## uncomment the following to brutally kill all of the users processes
#	sleep 5
#	pkill -u $username

## killing gnome-session should be more like:
	#DISPLAY=":0" XAUTHORITY="/tmp/.gdmEQ0V5T" SESSION_MANAGER="local/wretched:/tmp/.ICE-unix/$pid" su -c 'gnome-session-save --kill --silent' $username
## but this can still leave processes to cleanup - plus it's not easy to get SESSION_MANAGER

}

while(true); do
	# get the usernames and PIDs of sessions
	pidlists=$( ps --no-headers -fC $SESSION_MANAGER | awk 'BEGIN{ FS=" " } { print $1 "," $2 }' )
	for pidlist in $pidlists; do
		# split username and pid - FIXME: I bet this would be faster with bash arrays and substitution 
		username=$( echo $pidlist | awk 'BEGIN{ FS=","} { print $1}' )
		pid=$( echo $pidlist | awk 'BEGIN{ FS=","} { print $2}' )
		# check if user configfile exists
		if [[ -e "$TIMEKPRDIR/$username" ]]; then
			[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` configfile of $username exists" >> $LOGF
			# Read arrays: $from $to $limit
			source $TIMEKPRDIR/$username

			if [[ -e "$TIMEKPRDIR/$username.time" && `stat -c '%z' $TIMEKPRDIR/$username.time | cut -c9,10` == `date +%d` ]]; then
				# the time file exists and was last touched today, add $poll_time seconds to it
				[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` This day's $username.time file exists, adding time" >> $LOGF
				timekpr=$(( `cat $TIMEKPRDIR/$username.time` + $poll_time ))
				echo $timekpr > $TIMEKPRDIR/$username.time
			else  # the time file is missing or was last touched yesterday
				[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` Created $username.time file" >> $LOGF
				timekpr=$poll_time
				echo $timekpr > $TIMEKPRDIR/$username.time
			fi

			# Is the user allowed to be logged in at this time?
			# We take it for granted that if they are allowed to login all day ($default_limit) then
			# they can login whenever they want, ie they are normal users

			# Get current day index
			index=$(date +%w)
			[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` User $username PID $pid Day-Index: $index Seconds-passed: $timekpr" >> $LOGF

			# Compare: is current hour less than the one in $from array OR is greater/equal to $to array?
			if [[ $(date +%k) -lt ${from[$index]} || $(date +%k) -ge ${to[$index]} ]]; then
				[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` Current hour less than or greater than the defined hour in configfile" >> $LOGF
				# Has the user been given extended login hours?
				if [[ -e "$TIMEKPRDIR/$username.allow" ]]; then
					# Was the extended login hours given today?
					if [[ $(stat -c '%z' $TIMEKPRDIR/$username.allow | cut -c1-10) != $(date +%Y-%m-%d) ]]; then
						[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` Extended login hours detected $username.allow, but not in allowed period from-to" >> $LOGF
						notify "Only login between ${from[$index]} and ${to[$index]}"
						logOut
						rm $TIMEKPRDIR/$username.allow
					fi
				else
					# User has not been given extended login hours
					[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` Extended hours not detected, $username not in allowed period from-to" >> $LOGF
					notify "Only login between ${from[$index]} and ${to[$index]}"
					logOut
				fi
			fi

			# Is the limit exeeded
			if [[ $timekpr -ge ${limit[$index]} ]]; then
				[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` Seconds-passed exceeded todays limit" >> $LOGF
				# Has the user already been kicked out?
				if [[ -e "$TIMEKPRDIR/$username.logout" ]]; then
					# Was he kicked out today?
					if [[ $(stat -c '%z' $TIMEKPRDIR/$username.logout | cut -c1-10) == $(date +%Y-%m-%d) ]]; then
						[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` $username has been kicked out today" >> $LOGF
						logOut
					else
						# The user has not been kicked out today
						[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` $username has been kicked out, but not today" >> $LOGF
						notify "Daily time limit"
						logOut
					fi
				else
					# The user has not been kicked out today
					[[ $DEBUGME == "yes" ]] && echo "`date +'%Y-%m-%d %T %z'` Not found $username.logout" >> $LOGF
					notify "Daily time limit"
					logOut
				fi
			fi
		fi
	done
	# Wait a while before we check again
	sleep $poll_time
done

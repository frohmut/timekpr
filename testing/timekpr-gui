#!/usr/bin/env python
#TODO: Make it exclude administrators,sudoers,wheel members etc
import os, spwd, pwd, getpass, re, sys
from os.path import isdir, isfile

#VARIABLES
version = '0.2.0'
gladefile = 'timekpr.glade'
TIMEKPRDIR = '/etc/timekpr'
TIMEKPRWORK = '/var/lib/timekpr'

#IMPORT
#timekprmodules = '/usr/share/timekpr/'
timekprmodules = '../'
sys.path.append(timekprmodules)
from timekprpam import *

#Check if admin
if getpass.getuser() != "root":
	exit('Error: You do not have administrative privileges')

#Import GTK/PyGTK/Glade
try:
	import pygtk
	pygtk.require("2.0")
except:
	pass
try:
	import gtk
	import gtk.glade
except:
	exit(1)


# VARIABLES
configroot = '/etc/timekpr'

#Create configuration folder if not existing
if not isdir(configroot):
	os.mkdir(configroot)

#Check if it is a regular user, with userid within UID_MIN and UID_MAX.
def isnormal(username):
	userid = int(pwd.getpwnam(username)[2])
	logindefs = open('/etc/login.defs')
	uidminmax = re.compile('^UID_(?:MIN|MAX)\s+(\d+)',re.M).findall(logindefs.read())
	if uidminmax[0] < uidminmax[1]:
		uidmin = int(uidminmax[0])
		uidmax = int(uidminmax[1])
	else:
		uidmin = int(uidminmax[1])
		uidmax = int(uidminmax[0])
	if uidmin <= userid <= uidmax:
		return 1
	else:
		return 0

class timekprGUI:
	#This is the PyWine application
	def __init__(self):
		self.wTree = gtk.glade.XML(gladefile,'mainwindow')
		
		self.get_limit_spin()
		self.get_from_spin()
		self.get_to_spin()
		self.get_labels()
		
		self.singleLimits = self.wTree.get_widget("singleLimits")
		self.singleBoundaries = self.wTree.get_widget("singleBoundaries")
		self.limitCheck = self.wTree.get_widget("limitCheck")
		self.boundariesCheck = self.wTree.get_widget("boundariesCheck")
		self.userSelect = self.wTree.get_widget("userSelect")
		self.extendLimitsButton = self.wTree.get_widget("extendLimitsButton")
		self.rewardButton = self.wTree.get_widget("rewardButton")
		self.rewardSpin = self.wTree.get_widget("rewardSpin")
		self.labeluserstatus = self.wTree.get_widget("labeluserstatus")
		self.limiticon = self.wTree.get_widget("imagelimited1")
		self.boundariesicon = self.wTree.get_widget("imagelimited2")
		self.alldayloginicon = self.wTree.get_widget("imagealldaylogin")
		self.lockedicon = self.wTree.get_widget("imagelocked")
		
		dic = { "on_limitCheck_toggled": self.limitCheck_toggled,
			"on_boundariesCheck_toggled": self.boundariesCheck_toggled,
			"on_rewardButton_clicked": self.rewardButton_clicked,
			"on_extendLimitsButton_clicked": self.extendLimitsButton_clicked,
			"on_apply_clicked": self.apply_clicked,
			"on_singleBoundaries_toggled": self.singleBoundariesCheck_toggled,
			"on_singleLimits_toggled": self.singleLimitsCheck_toggled,
			"on_ok_clicked": self.ok_clicked,
			"on_userSelect_toggled": self.read_settings,
			"on_refresh_clicked": self.read_settings,
			"on_cancel_clicked": self.cancel_clicked,
			"on_aboutmenuitem_select": self.showaboutdialog,
			'gtk_main_quit': gtk.main_quit,
		}
		
		self.wTree.signal_autoconnect(dic)
		
		#Using /etc/shadow spwd module
		for userinfo in spwd.getspall():
			if isnormal(userinfo[0]) == 1:
				self.userSelect.append_text( userinfo[0] )
				self.userSelect.set_active( 0 )
		
		self.read_settings(self)
		return
	
	def showaboutdialog(self,*args):
		self.aboutdialog = gtk.glade.XML(gladefile,'aboutdialog')
		self.aboutd = self.aboutdialog.get_widget('aboutdialog')
		self.aboutd.set_version(version)
		self.response = self.aboutd.run()
		self.aboutd.destroy()
	
	def get_limit_spin(self):
		self.limitSpin = list()
		self.limitSpin.append(self.wTree.get_widget("limitSpin0"))
		self.limitSpin.append(self.wTree.get_widget("limitSpin1"))
		self.limitSpin.append(self.wTree.get_widget("limitSpin2"))
		self.limitSpin.append(self.wTree.get_widget("limitSpin3"))
		self.limitSpin.append(self.wTree.get_widget("limitSpin4"))
		self.limitSpin.append(self.wTree.get_widget("limitSpin5"))
		self.limitSpin.append(self.wTree.get_widget("limitSpin6"))
	
	def get_from_spin(self):
		self.fromSpin = list()
		self.fromSpin.append(self.wTree.get_widget("fromSpin0"))
		self.fromSpin.append(self.wTree.get_widget("fromSpin1"))
		self.fromSpin.append(self.wTree.get_widget("fromSpin2"))
		self.fromSpin.append(self.wTree.get_widget("fromSpin3"))
		self.fromSpin.append(self.wTree.get_widget("fromSpin4"))
		self.fromSpin.append(self.wTree.get_widget("fromSpin5"))
		self.fromSpin.append(self.wTree.get_widget("fromSpin6"))
	
	def get_to_spin(self):
		self.toSpin = list()
		self.toSpin.append(self.wTree.get_widget("toSpin0"))
		self.toSpin.append(self.wTree.get_widget("toSpin1"))
		self.toSpin.append(self.wTree.get_widget("toSpin2"))
		self.toSpin.append(self.wTree.get_widget("toSpin3"))
		self.toSpin.append(self.wTree.get_widget("toSpin4"))
		self.toSpin.append(self.wTree.get_widget("toSpin5"))
		self.toSpin.append(self.wTree.get_widget("toSpin6"))
	
	def get_labels(self):
		self.lb = list()
		self.lb.append(self.wTree.get_widget("lb0"))
		self.lb.append(self.wTree.get_widget("lb1"))
		self.lb.append(self.wTree.get_widget("lb2"))
		self.lb.append(self.wTree.get_widget("lb3"))
		self.lb.append(self.wTree.get_widget("lb4"))
		self.lb.append(self.wTree.get_widget("lb5"))
		self.lb.append(self.wTree.get_widget("lb6"))
		self.ll = list()
		self.ll.append(self.wTree.get_widget("ll0"))
		self.ll.append(self.wTree.get_widget("ll1"))
		self.ll.append(self.wTree.get_widget("ll2"))
		self.ll.append(self.wTree.get_widget("ll3"))
		self.ll.append(self.wTree.get_widget("ll4"))
		self.ll.append(self.wTree.get_widget("ll5"))
		self.ll.append(self.wTree.get_widget("ll6"))
	
	def ok_clicked(self, widget):
		self.apply_clicked(self)
		gtk.main_quit()
	
	def cancel_clicked(self, widget):
		gtk.main_quit()
	
	def rewardButton_clicked(self, widget):
		user = self.userSelect.get_active_text()
		arg = str(self.rewardSpin.get_value_as_int())
		cmd = 'timekpr-addtime ' + user + ' ' + arg
		os.system(cmd)
	
	def readfromtolimit(self, widget, user):
		#from-to time limitation (aka boundaries) - time.conf
		if isuserlimited(user) is True:
			#Get user time limits (boundaries) as lists from-to
			ulimits = getuserlimits(user)
			bfrom = ulimits[0]
			bto = ulimits[1]
			
			for i in range(7):
				self.fromSpin[i].set_value(float(bfrom[i]))
				self.toSpin[i].set_value(float(bto[i]))
			# Use boundaries?
			ub = True
			# Single boundaries? (set per day)
			sb = False
			
			#Are all boundaries the same?
			#If they're not same, activate single (per day) boundaries
			if ([bfrom[0]]*7) != (bfrom) or ([bto[0]]*7) != (bto):
				sb = True
			
			#Even if boundaries are Al0000-2400, return False
			if sb is False and bfrom[0] == str(0) and bto[0] == str(24):
				ub = False
			
			self.boundariesCheck.set_active(ub)
			self.singleBoundaries.set_active(sb)
		else:
			for i in range(7):
				self.fromSpin[i].set_value(7)
				self.toSpin[i].set_value(22)
			self.boundariesCheck.set_active(False)
			self.singleBoundaries.set_active(False)
	
	def readdurationlimit(self, widget, user):
		#time length limitation
		configFile = configroot + '/' + user
		if isfile(configFile):
			fileHandle = open(configFile)
			limits = fileHandle.readline()
			limits = limits.replace("limit=( ","")
			limits = limits.replace(")", "")
			limits = limits.split(" ")
			
			for i in range(7):
				self.limitSpin[i].set_value(float(limits[i])/60)
			
			# Single limits? (set per day)
			sl = False
			# Use limits?
			ul = True
			
			for i in range(1, 7):
				if limits[i] != limits[i-1]:
					sl = True
				#if (bfrom[i] != bfrom[i-1]) or (bto[i] != bto[i-1]):
				#	sb = True
			
			if limits[0] == '86400' and not sl: ul = False
			self.limitCheck.set_active(ul)
			self.singleLimits.set_active(sl)
		else:
			for i in range(7): self.limitSpin[i].set_value(300)
			self.limitCheck.set_active(False)
			self.singleLimits.set_active(False)
	
	def statusicons(self, widget, user):
		#Set icons in status gtk-yes or gtk-no
		iconyes = gtk.STOCK_YES
		iconno = gtk.STOCK_NO
		iconsize = gtk.ICON_SIZE_BUTTON
		#limitSpin status is already set, so we can use it
		#self.spinlimitvalue = self.wTree.get_widget("limitSpin" + strftime('%w')).get_value()
		if self.limitCheck.get_active(): self.limiticon.set_from_stock(iconyes,iconsize)
		else: self.boundariesicon.set_from_stock(iconno,iconsize)
		
		if self.boundariesCheck.get_active(): self.boundariesicon.set_from_stock(iconyes,iconsize)
		else: self.boundariesicon.set_from_stock(iconno,iconsize)
		
		if not isuserlimitedtoday(user) and not isuserlocked(user): self.alldayloginicon.set_from_stock(iconyes,iconsize)
		else: self.alldayloginicon.set_from_stock(iconno,iconsize)
		
		if isuserlocked(user): self.lockedicon.set_from_stock(iconyes,iconsize)
		else: self.lockedicon.set_from_stock(iconno,iconsize)
	
	def read_settings(self, widget):
		user = self.userSelect.get_active_text()
		self.readfromtolimit(self, user)
		self.readdurationlimit(self, user)
		self.labeluserstatus.set_label('Status for <span weight="bold">'+user+'</span>')
		self.statusicons(self, user)
	
	def extendLimitsButton_clicked(self, widget):
		user = self.userSelect.get_active_text()
		cmd = 'timekpr-extend ' + user
		os.system(cmd)
	
	def boundariesCheck_toggled(self, widget):
		if self.boundariesCheck.get_active():
			self.fromSpin[0].set_sensitive(True)
			self.toSpin[0].set_sensitive(True)
			self.singleBoundaries.set_sensitive(True)
			self.wTree.get_widget("labelTo").set_sensitive(True)
			self.wTree.get_widget("labelFrom").set_sensitive(True)
			self.lb[0].set_sensitive(True)
		else:
			self.fromSpin[0].set_sensitive(False)
			self.toSpin[0].set_sensitive(False)
			self.singleBoundaries.set_sensitive(False)
			self.wTree.get_widget("labelTo").set_sensitive(False)
			self.wTree.get_widget("labelFrom").set_sensitive(False)
			self.lb[0].set_sensitive(False)
		self.singleBoundariesCheck_toggled(self)
	
	def singleBoundariesCheck_toggled(self, widget):
		if self.singleBoundaries.get_active() and self.boundariesCheck.get_active():
			for i in range(1, 7):
				self.fromSpin[i].set_sensitive(True)
				self.toSpin[i].set_sensitive(True)
				self.lb[i].set_sensitive(True)
			self.lb[0].set_text("	Sun	 ")
		else:
			for i in range(1, 7):
				self.fromSpin[i].set_sensitive(False)
				self.toSpin[i].set_sensitive(False)
				self.lb[i].set_sensitive(False)
			self.lb[0].set_text("Every day")
	
	def limitCheck_toggled(self, widget):
		if self.limitCheck.get_active():
			self.limitSpin[0].set_sensitive(True)
			self.singleLimits.set_sensitive(True)
			self.wTree.get_widget("labelMinutes").set_sensitive(True)
			self.ll[0].set_sensitive(True)
		else:
			self.limitSpin[0].set_sensitive(False)
			self.singleLimits.set_sensitive(False)
			self.wTree.get_widget("labelMinutes").set_sensitive(False)
			self.ll[0].set_sensitive(False)
		self.singleLimitsCheck_toggled(self)
	
	def singleLimitsCheck_toggled(self, widget):
		if self.singleLimits.get_active() and self.limitCheck.get_active():
			for i in range(1, 7):
				self.ll[i].set_sensitive(True)
				self.limitSpin[i].set_sensitive(True)
			self.ll[0].set_text("	Sun	 ")
		else:
			for i in range(1, 7):
				self.ll[i].set_sensitive(False)
				self.limitSpin[i].set_sensitive(False)
			self.ll[0].set_text("Every day")
	
	def apply_clicked(self, widget):
		user = self.userSelect.get_active_text()
		print "User=" + user
		space = " "
		limit = "limit=( 86400 86400 86400 86400 86400 86400 86400 )"
		#bTo = "to=( 24 24 24 24 24 24 24 )"
		#bFrom = "from=( 0 0 0 0 0 0 0 )"
		#timekprpam.py adduserlimits() takes lists
		bFrom = ['0']*7
		bTo = ['24']*7
		
		if self.limitCheck.get_active():
			if self.singleLimits.get_active():
				limit = "limit=("
				for i in range(7):
					limit = limit + space + str(self.limitSpin[i].get_value_as_int() * 60)
				limit = limit + space + ")"
			else:
				limit = "limit=("
				for i in range(7):
					limit = limit + space + str(self.limitSpin[0].get_value_as_int() * 60)
				limit = limit + space + ")"
		if self.boundariesCheck.get_active():
			if self.singleBoundaries.get_active():
				bFrom = []
				bTo = []
				for i in range(7):
					bFrom.append(str(self.fromSpin[i].get_value_as_int()))
					bTo.append(str(self.toSpin[i].get_value_as_int()))
			else:
				bFrom = []
				bTo = []
				for i in range(7):
					bFrom.append(str(self.fromSpin[0].get_value_as_int()))
					bTo.append(str(self.toSpin[0].get_value_as_int()))
		configFile = configroot + '/' + self.userSelect.get_active_text()
		if self.limitCheck.get_active():
			fH = open(configFile, 'w')
			fH.write(limit + "\n")
			fH.close()
		else:
			try: os.remove(configFile)
			except OSError: pass
		
		#No need to check if boundaries are active or not, apply the default or custom limits
		#Remove old user limits (boundaries)
		print "remove old boundaries"
		rb = removeuserlimits(user)
		if rb is False: exit('Could not remove (old) user boundaries')
		#Add new limits (boundaries)
		print "add new boundaries"
		ab = adduserlimits(user,bFrom,bTo)
		if ab is False: exit('Could not add (new) user boundaries')

if __name__ == "__main__":
	tkg = timekprGUI()
	gtk.main()
